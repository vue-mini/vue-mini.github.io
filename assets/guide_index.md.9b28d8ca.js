import{o as e,c as i,a as t}from"./app.8efcc44e.js";const r='{"title":"介绍","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么？","slug":"为什么？"},{"level":2,"title":"它是如何工作的？","slug":"它是如何工作的？"}],"relativePath":"guide/index.md","lastUpdated":1622194741199}',a={},o=t('<h1 id="介绍"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h1><div class="warning custom-block"><p class="custom-block-title">⚠️</p><p>此文档还在编写中。</p></div><div class="tip custom-block"><p class="custom-block-title">注意</p><p>阅读本文档前请先阅读<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener noreferrer">小程序开发文档</a>以及 <a href="https://composition-api.vuejs.org/" target="_blank" rel="noopener noreferrer">Vue Composition API 文档</a>，本文档将不再重复它们已有的内容。</p></div><p>Vue Mini 是一个基于 Vue 3 的小程序开发库，它能让你用 Composition API 写小程序。与某些小程序开发方案不同的是 Vue Mini 仅仅是一个轻量的运行时库，它既不依赖任何编译步骤，也不涉及任何 Virtual DOM。并且 Vue Mini 从一开始就被设计为能跟小程序原生语法协同工作，你甚至能在同一个页面或组件内混用原生语法与 Vue Mini，这能让你很轻松的将其整合进既有项目中。当然，你也能完全使用 Vue Mini 开发一个小程序。</p><p>Vue Mini 仅聚焦于小程序逻辑部分，也就是 JS 部分，它并不影响小程序的模版、样式及配置。</p><h2 id="为什么？"><a class="header-anchor" href="#为什么？" aria-hidden="true">#</a> 为什么？</h2><p>Vue 3 之所以提出 Composition API 是为了解决：逻辑复用、复杂代码组织以及更好的 TypeScript 支持这三大问题。而小程序也有这些问题，并且小程序没有响应式数据，每次更新数据需要调用 <code>setData</code>。Vue 的响应式数据 + Composition API 能非常好的解决这些问题，于是就有了 Vue Mini。</p><h2 id="它是如何工作的？"><a class="header-anchor" href="#它是如何工作的？" aria-hidden="true">#</a> 它是如何工作的？</h2><p>Vue Mini 底层直接依赖于 <a href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity" target="_blank" rel="noopener noreferrer">@vue/reactivity</a>，它是 Vue 3 的响应式核心。事实上，你可以简单的将 Vue Mini 理解为 @vue/reactivity 与小程序的绑定。它会在适当的时机调用 <code>setup</code> 函数，并监听返回的响应式数据，如果数据变化了，就调用 <code>setData</code> 通知小程序。如果返回的是方法，就将其添加到小程序上。如果你在 <code>setup</code> 函数内调用生命周期钩子函数，Vue Mini 也会将其动态注入到小程序上。</p>',9);a.render=function(t,r,a,n,s,p){return e(),i("div",null,[o])};export default a;export{r as __pageData};
